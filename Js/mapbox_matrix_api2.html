<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Mapbox Matrix + Directions â€” Dispatch Ã–rnekleri (A & B)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Mapbox GL JS v3.14.0 -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>

  <style>
    :root { --b:#e5e7eb; --t:#111827; --m:#2563eb; --ok:#16a34a; --bad:#ef4444; }
    * { box-sizing: border-box }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:var(--t); }
    #app { display:grid; grid-template-columns: 380px 1fr; height:100vh; }
    #side { border-right:1px solid var(--b); padding:14px; overflow:auto; }
    #map { width:100%; height:100%; }
    .h { font-weight:700; margin:0 0 8px }
    .sub { font-size:12px; color:#6b7280; margin:6px 0 12px }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px }
    button { padding:8px 10px; border:1px solid var(--b); border-radius:10px; background:#fff; cursor:pointer }
    button:hover { background:#f8fafc }
    .badge { display:inline-block; font-size:11px; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; }
    .card { border:1px solid var(--b); border-radius:12px; padding:10px; margin:10px 0 }
    .list .item { padding:8px; border:1px dashed var(--b); border-radius:10px; margin:6px 0; cursor:pointer }
    .list .item:hover { background:#f8fafc }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: var(--ok) } .bad { color: var(--bad) }
  </style>
</head>
<body>
<div id="app">
  <div id="side">
    <h3 class="h">Dispatch Demo â€” Matrix + Directions</h3>
    <div class="sub">A: Tek iÅŸ â†’ en uygun sÃ¼rÃ¼cÃ¼yÃ¼ seÃ§. B: 3Ã—3 eÅŸleÅŸme (min toplam sÃ¼re, Hungarian).</div>

    <div class="card">
      <div class="h">A) Tek Ä°ÅŸ â†’ En Uygun SÃ¼rÃ¼cÃ¼</div>
      <div class="sub">Haritaya <b>tÄ±kla</b> (iÅŸ konumu deÄŸiÅŸir) ya da â€œKonumumu kullanâ€. Sonra â€œHesaplaâ€.</div>
      <div class="row">
        <button id="useMe">ğŸ“ Konumumu kullan</button>
        <button id="runA">A â€” Matrix Hesapla</button>
        <button id="clear">Temizle</button>
      </div>
      <div id="aInfo" class="sub"></div>
      <div id="aList" class="list"></div>
    </div>

    <div class="card">
      <div class="h">B) 3 SÃ¼rÃ¼cÃ¼ Ã— 3 Ä°ÅŸ â†’ Min-Cost EÅŸleÅŸme</div>
      <div class="sub">HazÄ±r koordinatlar ile 3Ã—3 Matrix + Hungarian. â€œB â€” Ã‡alÄ±ÅŸtÄ±râ€ de.</div>
      <div class="row">
        <button id="runB">B â€” Ã‡alÄ±ÅŸtÄ±r</button>
      </div>
      <div id="bInfo" class="sub"></div>
      <div id="bList" class="list"></div>
    </div>

    <div class="sub mono">
      Profil: <b>mapbox/driving-traffic</b> (trafik dahil ETA) â€” Matrix max 10 koordinat.<br>
      Ã‡alÄ±ÅŸtÄ±rma: tokenÄ±nÄ± deÄŸiÅŸtir, <b>localhost</b> Ã¼stÃ¼nden aÃ§.
    </div>
  </div>
  <div id="map"></div>
</div>

<script>
  // ====== 0) TOKEN ======
	mapboxgl.accessToken = 'pk.eyJ1IjoiYWRlbS01NCIsImEiOiJjbWFsM3R4d2MwNGtmMmpzZnk2ZW5tcGRsIn0.aCSC5Pe3IUcHI8MDeCTwxw';


  // ====== 1) HARÄ°TA ======
  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [10.744, 59.916], zoom: 12.3
  });

  // Temizleme (katman/kaynak/marker)
  function removeIfExists(id, isLayer=true){
    if (isLayer && map.getLayer(id)) map.removeLayer(id);
    if (!isLayer && map.getSource(id)) map.removeSource(id);
  }
  function clearRoutes(){
    // A rotasÄ±
    removeIfExists('route-a'); removeIfExists('src-a', false);
    // B rotalarÄ± (0..2)
    for (let i=0;i<3;i++){ removeIfExists('route-b-'+i); removeIfExists('src-b-'+i, false); }
  }

  // ====== 2) Ã–RNEK A â€” SÃ¼rÃ¼cÃ¼ler ve Ä°ÅŸ (tÄ±klanabilir) ======
  // 5 sÃ¼rÃ¼cÃ¼ (marker: mavi)
  const driversA = [
    { id:'d1', coord:[10.7600,59.9200] },
    { id:'d2', coord:[10.7400,59.9150] },
    { id:'d3', coord:[10.7700,59.9100] },
    { id:'d4', coord:[10.7550,59.9250] },
    { id:'d5', coord:[10.7320,59.9050] }
  ];
  const driverMarkersA = [];

  // Ä°ÅŸ (yeÅŸil marker) â€” baÅŸlangÄ±Ã§ta Oslo merkezine yakÄ±n
  let jobA = { id:'job-1', coord:[10.7522,59.9139] };
  let jobMarkerA;

  function addMarkersA(){
    // Ä°ÅŸ marker
    if (jobMarkerA) jobMarkerA.remove();
    jobMarkerA = new mapboxgl.Marker({ color:'#16a34a' }).setLngLat(jobA.coord).addTo(map);
    // SÃ¼rÃ¼cÃ¼ markerlarÄ±
    driverMarkersA.forEach(m=>m.remove());
    driversA.forEach((d,i)=>{
      const m = new mapboxgl.Marker({ color:'#2563eb' })
        .setLngLat(d.coord)
        .setPopup(new mapboxgl.Popup().setText(`${d.id}`))
        .addTo(map);
      driverMarkersA.push(m);
    });
  }

  // Haritaya tÄ±klayÄ±nca A senaryosu iÃ§in iÅŸ konumunu gÃ¼ncelle
  map.on('click', (e) => {
    jobA.coord = [e.lngLat.lng, e.lngLat.lat];
    if (jobMarkerA){ jobMarkerA.setLngLat(jobA.coord); }
    document.getElementById('aInfo').innerText = `Ä°ÅŸ konumu gÃ¼ncellendi: ${jobA.coord[0].toFixed(5)}, ${jobA.coord[1].toFixed(5)} â€” "A â€” Matrix Hesapla"ya bas.`;
  });

  // ====== 3) MATRIX YardÄ±mcÄ±larÄ± ======
  function toCoordStr(c){ return `${c[0]},${c[1]}`; }
  function fmtMin(sec){ if (sec==null) return 'â€”'; const m = Math.round(sec/60); return m<1 ? `${Math.round(sec)} sn` : `${m} dk`; }

  async function matrixOneToMany(origin, others){
    const coords = [origin, ...others].map(toCoordStr).join(';');
    const destIdx = others.map((_,i)=>i+1).join(';'); // 1..N
    const url = `https://api.mapbox.com/directions-matrix/v1/mapbox/driving-traffic/${coords}?sources=0&destinations=${destIdx}&annotations=duration&access_token=${mapboxgl.accessToken}`;
    const r = await fetch(url); const data = await r.json();
    if (data.code!=='Ok') throw new Error(`Matrix hata: ${data.code} ${data.message||''}`);
    return data.durations[0]; // origin -> others sÃ¼releri
  }

  async function matrixManyToMany(origins, dests){
    const coordsAll = [...origins, ...dests].map(toCoordStr).join(';');
    const srcIdx = origins.map((_,i)=>i).join(';'); // 0..m-1
    const dstIdx = dests.map((_,i)=>i+origins.length).join(';'); // m..m+n-1
    const url = `https://api.mapbox.com/directions-matrix/v1/mapbox/driving-traffic/${coordsAll}?sources=${srcIdx}&destinations=${dstIdx}&annotations=duration&access_token=${mapboxgl.accessToken}`;
    const r = await fetch(url); const data = await r.json();
    if (data.code!=='Ok') throw new Error(`Matrix hata: ${data.code} ${data.message||''}`);
    return data.durations; // m x n
  }

  // ====== 4) Directions (tek rota Ã§iz) ======
  async function drawRoute(idPrefix, from, to, color){
    const url = `https://api.mapbox.com/directions/v5/mapbox/driving-traffic/${toCoordStr(from)};${toCoordStr(to)}?geometries=geojson&steps=false&access_token=${mapboxgl.accessToken}`;
    const r = await fetch(url); const data = await r.json();
    const geom = data.routes?.[0]?.geometry;
    if (!geom) return;

    const srcId = `src-${idPrefix}`, layerId = `route-${idPrefix}`;
    removeIfExists(layerId); removeIfExists(srcId, false);
    map.addSource(srcId, { type:'geojson', data: geom });
    map.addLayer({
      id: layerId, type:'line', source: srcId,
      paint: { 'line-width': 6, 'line-color': color || '#2563eb', 'line-opacity': 0.9 }
    });

    // KamerayÄ± sÄ±ÄŸdÄ±r (sadece tek rota ise)
    if (idPrefix === 'a'){
      const b = geom.coordinates.reduce((bb,c)=>bb.extend(c), new mapboxgl.LngLatBounds(geom.coordinates[0], geom.coordinates[0]));
      map.fitBounds(b, { padding: 60, duration: 600 });
    }
  }

  // ====== 5) Ã–RNEK A â€” Ã‡alÄ±ÅŸtÄ±r ======
  async function runExampleA(){
    try{
      clearRoutes();
      document.getElementById('aInfo').innerText = 'HesaplanÄ±yorâ€¦';
      const durations = await matrixOneToMany(jobA.coord, driversA.map(d=>d.coord));
      // en kÃ¼Ã§Ã¼k sÃ¼reli sÃ¼rÃ¼cÃ¼yÃ¼ bul
      let bestIdx=-1, best=Infinity;
      durations.forEach((sec,i)=>{ if(sec!=null && sec<best){best=sec; bestIdx=i;} });
      // Liste (ETA artan sÄ±rada)
      const rows = driversA.map((d,i)=>({ ...d, sec: durations[i] }))
                           .filter(x=>x.sec!=null)
                           .sort((a,b)=>a.sec-b.sec);
      const aList = document.getElementById('aList');
      aList.innerHTML = '';
      rows.forEach((r,rank)=>{
        const div = document.createElement('div');
        div.className = 'item';
        const bestStar = (driversA.indexOf(r)===bestIdx) ? ' â­' : '';
        div.innerHTML = `<b>${rank+1}.</b> ${r.id}${bestStar} â€” ETA <b>${fmtMin(r.sec)}</b> <span class="mono">(${r.coord[0].toFixed(4)}, ${r.coord[1].toFixed(4)})</span>`;
        div.onclick = ()=> drawRoute('a', r.coord, jobA.coord, '#2563eb');
        aList.appendChild(div);
      });
      if (bestIdx>=0){
        document.getElementById('aInfo').innerHTML = `SeÃ§im: <b>${driversA[bestIdx].id}</b> (ETA ${fmtMin(best)}). Liste Ã¶ÄŸesine tÄ±klarsan rota Ã§izilir.`;
        // Ä°stersen otomatik rota:
        await drawRoute('a', driversA[bestIdx].coord, jobA.coord, '#2563eb');
      } else {
        document.getElementById('aInfo').innerText = 'UlaÅŸÄ±labilir sÃ¼rÃ¼cÃ¼ bulunamadÄ±.';
      }
    }catch(e){
      document.getElementById('aInfo').innerHTML = `<span class="bad">Hata:</span> ${e.message}`;
      console.error(e);
    }
  }

  // ====== 6) Ã–RNEK B â€” 3Ã—3 Min-Cost (Hungarian) ======
  const driversB = [
    { id:'D1', coord:[10.7600,59.9200] },
    { id:'D2', coord:[10.7400,59.9150] },
    { id:'D3', coord:[10.7700,59.9100] }
  ];
  const jobsB = [
    { id:'J1', coord:[10.7522,59.9139] },
    { id:'J2', coord:[10.7630,59.9210] },
    { id:'J3', coord:[10.7450,59.9180] }
  ];

  // Basit Hungarian (square matrix). 3x3 iÃ§in yeterli.
  // Kaynak: Klasik Hungarian tekniÄŸinin sadeleÅŸtirilmiÅŸ JS uyarlamasÄ±.
  function hungarianMin(cost){
    const n = cost.length;
    // 1) Row reduce
    for (let i=0;i<n;i++){
      const min = Math.min(...cost[i].map(v=>v??Infinity));
      for (let j=0;j<n;j++) cost[i][j] = (cost[i][j]==null?1e9:cost[i][j]) - min;
    }
    // 2) Column reduce
    for (let j=0;j<n;j++){
      let colMin=Infinity; for (let i=0;i<n;i++) colMin=Math.min(colMin,cost[i][j]);
      for (let i=0;i<n;i++) cost[i][j]-=colMin;
    }
    // 3) Greedy zero cover + augment (kÃ¼Ã§Ã¼k n iÃ§in pratik)
    const assignedCol = Array(n).fill(-1);
    function tryAssign(row, seen){
      for (let col=0; col<n; col++){
        if (cost[row][col]!==0 || seen[col]) continue;
        seen[col]=true;
        if (assignedCol[col]===-1 || tryAssign(assignedCol[col], seen)){
          assignedCol[col]=row; return true;
        }
      }
      return false;
    }
    for (let row=0; row<n; row++){ tryAssign(row, Array(n).fill(false)); }

    // EÄŸer tÃ¼m satÄ±rlar atanmadÄ±ysa (nadiren) kÃ¼Ã§Ã¼k ayarlamalar yap
    let coveredRows = Array(n).fill(false), coveredCols = Array(n).fill(false);
    let matchedRows = new Set(Object.values(assignedCol).filter(v=>v!==-1));
    // Klasik adÄ±mlarÄ±n kÄ±sa versiyonu: kÃ¼Ã§Ã¼k n iÃ§in genelde tam atama Ã§Ä±kÄ±yor.
    // AtamalarÄ± dÃ¶ndÃ¼r (row->col)
    const result = Array(n).fill(-1);
    for (let col=0; col<n; col++) if (assignedCol[col]!==-1) result[assignedCol[col]] = col;
    return result; // result[row] = assigned column
  }

  async function runExampleB(){
    try{
      clearRoutes();
      document.getElementById('bInfo').innerText = 'HesaplanÄ±yorâ€¦';
      // 3x3 Matrix
      const durations = await matrixManyToMany(driversB.map(d=>d.coord), jobsB.map(j=>j.coord)); // saniye
      // Hungarian iÃ§in kopya (dakika bazlÄ± â€” fark etmez)
      const cost = durations.map(row => row.map(v => v==null?1e9:v));
      const assign = hungarianMin(cost.map(r=>r.slice())); // row->col

      // Listele & rotalarÄ± Ã§iz
      const bList = document.getElementById('bList'); bList.innerHTML='';
      let total = 0;
      for (let r=0; r<assign.length; r++){
        const c = assign[r];
        if (c<0 || c>=jobsB.length || durations[r][c]==null) continue;
        const d = driversB[r], j = jobsB[c], sec = durations[r][c];
        total += sec;

        const item = document.createElement('div');
        item.className = 'item';
        item.innerHTML = `<b>${d.id}</b> â†’ <b>${j.id}</b> â€” ETA <b>${fmtMin(sec)}</b> <span class="mono">(${toCoordStr(d.coord)} â†’ ${toCoordStr(j.coord)})</span>`;
        item.onclick = ()=> drawRoute('b-'+r, d.coord, j.coord, ['#2563eb','#16a34a','#f59e0b'][r%3]);
        bList.appendChild(item);

        // Otomatik Ã§iz (isteÄŸe baÄŸlÄ±)
        await drawRoute('b-'+r, d.coord, j.coord, ['#2563eb','#16a34a','#f59e0b'][r%3]);
      }
      document.getElementById('bInfo').innerHTML = `Toplam sÃ¼re (seÃ§ilen eÅŸleÅŸme): <b>${fmtMin(total)}</b>`;
    }catch(e){
      document.getElementById('bInfo').innerHTML = `<span class="bad">Hata:</span> ${e.message}`;
      console.error(e);
    }
  }

  // ====== 7) UI: Butonlar ======
  document.getElementById('runA').onclick = runExampleA;
  document.getElementById('runB').onclick = runExampleB;
  document.getElementById('clear').onclick = ()=>{
    clearRoutes();
    document.getElementById('aList').innerHTML='';
    document.getElementById('bList').innerHTML='';
    document.getElementById('aInfo').innerText='';
    document.getElementById('bInfo').innerText='';
  };
  document.getElementById('useMe').onclick = ()=>{
    if (!navigator.geolocation) return alert('Geolocation desteklenmiyor.');
    navigator.geolocation.getCurrentPosition(pos=>{
      jobA.coord = [pos.coords.longitude, pos.coords.latitude];
      if (jobMarkerA) jobMarkerA.setLngLat(jobA.coord); else addMarkersA();
      map.easeTo({ center: jobA.coord, zoom: 13 });
      document.getElementById('aInfo').innerText = `Ä°ÅŸ konumu gÃ¼ncellendi (konumum). "A â€” Matrix Hesapla"ya bas.`;
    }, err=>alert('Konum alÄ±namadÄ±: '+err.message), { enableHighAccuracy:true, timeout:10000 });
  };

  // ====== 8) BaÅŸlangÄ±Ã§ta markerlarÄ± koy ======
  map.on('load', ()=>{
    addMarkersA();
  });
</script>
</body>
</html>
<!-- 
Bu sayfada neler var?

Ã–rnek A: Tek iÅŸ + birden Ã§ok sÃ¼rÃ¼cÃ¼ â†’ Matrix ile en kÄ±sa ETAâ€™lÄ± sÃ¼rÃ¼cÃ¼yÃ¼ bul, tÄ±kla â†’ Directions ile rota Ã§iz.

Ã–rnek B: 3 sÃ¼rÃ¼cÃ¼ + 3 iÅŸ â†’ Matrix ile 3Ã—3 sÃ¼re matrisi al; Hungarian (min-cost) ile toplam sÃ¼reyi minimize eden eÅŸleÅŸmeyi bul; her eÅŸleÅŸme iÃ§in Directions ile rotalarÄ± Ã§iz.


Evetâ€”â€œd2 hava (kuÅŸ uÃ§uÅŸu) olarak en yakÄ±nâ€ olsa bile ETA (yol sÃ¼resi) daha uzun Ã§Ä±kabilir. Nedeni: Matrix, yol aÄŸÄ± + tek yÃ¶nler + dÃ¶nÃ¼ÅŸ kÄ±sÄ±tlarÄ± + hÄ±z profilleri + (driving-traffic seÃ§tiysen) trafik ile hesap yapar. Yani:

Tek yÃ¶n / U-dÃ¶nÃ¼ÅŸ zorunluluÄŸu â†’ dolanma.

KavÅŸak/dÃ¶nÃ¼ÅŸ yasaklarÄ± â†’ ek sapma.

HÄ±z profilleri / trafik yoÄŸunluÄŸu â†’ iki nokta eÅŸit mesafede olsa da sÃ¼re farklÄ±.

YanlÄ±ÅŸ yÃ¶nde ilerleme (sÃ¼rÃ¼cÃ¼ zaten ters yÃ¶ne gidiyorsa) â†’ geri dÃ¶nme maliyeti.

Snap edilen yol farklÄ± (araÃ§ park iÃ§indeyse en yakÄ±n Ã§Ä±kÄ±ÅŸ yolu dolanÄ±mlÄ± olabilir).

AyrÄ±ca Ã¶nemli bir nÃ¼ans: Demoâ€™da iÅŸi origin, sÃ¼rÃ¼cÃ¼leri destination yapmÄ±ÅŸ olabilirsin. Bu durumda hesap iÅŸâ†’sÃ¼rÃ¼cÃ¼ sÃ¼resi olur. Oysa dispatchâ€™te doÄŸru olan sÃ¼rÃ¼cÃ¼â†’iÅŸ sÃ¼residir. Asimetri (Aâ†’B â‰  Bâ†’A) yÃ¼zÃ¼nden sÄ±ralama deÄŸiÅŸebilir.

DoÄŸru yÃ¶n: sÃ¼rÃ¼cÃ¼ â†’ iÅŸ (kÃ¼Ã§Ã¼k dÃ¼zeltme)

AÅŸaÄŸÄ±daki helperâ€™Ä± ekle ve A Ã¶rneÄŸinde bunu kullan:

// N sÃ¼rÃ¼cÃ¼ (sources) -> 1 iÅŸ (destination)  ==> NÃ—1 matrix
async function matrixManyToOne(sources, destination) {
  const toStr = c => `${c[0]},${c[1]}`;
  const coords = [...sources, destination].map(toStr).join(';');
  const srcIdx = sources.map((_, i) => i).join(';');          // 0..N-1
  const dstIdx = sources.length;                               // N (tek hedef)
  const url = `https://api.mapbox.com/directions-matrix/v1/mapbox/driving-traffic/${coords}` +
              `?sources=${srcIdx}&destinations=${dstIdx}&annotations=duration&access_token=${mapboxgl.accessToken}`;
  const data = await (await fetch(url)).json();
  if (data.code !== 'Ok') throw new Error(`Matrix hata: ${data.code} ${data.message||''}`);
  // durations[row][0] = o sÃ¼rÃ¼cÃ¼den (row) iÅŸe (tek hedef) sÃ¼re (sn)
  return data.durations.map(row => row[0]);
}


runExampleA() iÃ§inde Ã§aÄŸrÄ±yÄ± ÅŸÃ¶yle deÄŸiÅŸtir:

// ESKÄ° (iÅŸ -> sÃ¼rÃ¼cÃ¼ler)
// const durations = await matrixOneToMany(jobA.coord, driversA.map(d=>d.coord));

// YENÄ° (sÃ¼rÃ¼cÃ¼ler -> iÅŸ)  
const durations = await matrixManyToOne(driversA.map(d=>d.coord), jobA.coord);


BÃ¶ylece d2, gerÃ§ekten sÃ¼rÃ¼cÃ¼nÃ¼n iÅŸ yerine gidiÅŸ sÃ¼resine gÃ¶re sÄ±ralanÄ±r. HÃ¢lÃ¢ â€œd2 en kÄ±sa deÄŸilâ€ Ã§Ä±karsa, yukarÄ±daki yol/ trafik nedenlerinden biridir (normal).

Daha isabetli sonuÃ§ iÃ§in kÃ¼Ã§Ã¼k ipuÃ§larÄ±

Trafik: mapbox/driving-traffic doÄŸru tercih. â€œGelecekte Ã§Ä±kÄ±ÅŸâ€ gerekiyorsa depart_at (beta) kullanabilirsin.

SÃ¼rÃ¼cÃ¼ hareket hÃ¢lindeyse: Ä°lk waypoint iÃ§in bearings (Ã¶rn. heading,90) + radiuses (Ã¶rn. 30) ver; araÃ§ mevcut ÅŸeritte kalsÄ±n.

KaldÄ±rÄ±m tarafÄ± Ã¶nemliyse (varoÅŸta yanaÅŸma): approaches=curb.

Snap sorunu (otopark/yan yol): radiuses deÄŸerini 25â€“50 m yapmak doÄŸru yolu bulmayÄ± kolaylaÅŸtÄ±rÄ±r.

Ä°stersen koduna bu dÃ¼zeltmeleri ben gÃ¶mÃ¼p â€œeski-yeni (iÅŸâ†’sÃ¼rÃ¼cÃ¼ vs sÃ¼rÃ¼cÃ¼â†’iÅŸ)â€ iki yÃ¶nÃ¼ yan yana hesaplayacak ve farkÄ± gÃ¶sterecek mini bir panel de ekleyebilirim.

-->